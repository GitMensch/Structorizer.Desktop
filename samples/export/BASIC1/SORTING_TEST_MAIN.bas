REM Creates three equal arrays of numbers and has them sorted with different sorting algorithms 
REM to allow performance comparison via execution counting ("Collect Runtime Data" should 
REM sensibly be switched on). 
REM Requested input data are: Number of elements (size) and filing mode. 
REM Generated by Structorizer 3.30-02 
REM  
REM Copyright (C) 2019-10-02 Kay Gürtzig 
REM License: GPLv3-link 
REM GNU General Public License (V 3) 
REM https://www.gnu.org/licenses/gpl.html 
REM http://www.gnu.de/documents/gpl.de.html 
REM  
REM  
REM program SORTING_TEST_MAIN
REM TODO: declare your variables here: 
  REM DIM values3 AS <type> 
  REM DIM values2 AS <type> 
  REM DIM values1 AS <type> 
  REM DIM show AS <type> 
  REM DIM ok3 AS <type> 
  REM DIM ok2 AS <type> 
  REM DIM ok1 AS <type> 
  REM DIM modus AS <type> 
  REM DIM i AS <type> 
  REM DIM elementCount AS <type> 
REM  
DO
  INPUT elementCount
LOOP UNTIL elementCount >= 1
DO
  PRINT "Filling: 1 = random, 2 = increasing, 3 = decreasing"; : INPUT modus
LOOP UNTIL modus = 1 OR modus = 2 OR modus = 3
FOR i = 0 TO elementCount-1
  SELECT CASE modus
    CASE 1
      values1(i) = random(10000)
    CASE 2
      values1(i) = i
    CASE 3
      values1(i) = -i
  END SELECT
NEXT i
REM Kopiere das Array für exakte Vergleichbarkeit 
FOR i = 0 TO elementCount-1
  values2(i) = values1(i)
  values3(i) = values1(i)
NEXT i

REM ========================================================== 
REM ================= START PARALLEL SECTION ================= 
REM ========================================================== 
REM TODO: add the necessary code to run the threads concurrently 

  REM ----------------- START THREAD 0 ----------------- 
    CALL bubbleSort(values1)
  REM ------------------ END THREAD 0 ------------------ 


  REM ----------------- START THREAD 1 ----------------- 
    CALL quickSort(values2, 0, elementCount)
  REM ------------------ END THREAD 1 ------------------ 


  REM ----------------- START THREAD 2 ----------------- 
    CALL heapSort(values3)
  REM ------------------ END THREAD 2 ------------------ 

REM ========================================================== 
REM ================== END PARALLEL SECTION ================== 
REM ========================================================== 

CALL ok1 = testSorted(values1)
CALL ok2 = testSorted(values2)
CALL ok3 = testSorted(values3)
IF NOT ok1 OR NOT ok2 OR NOT ok3 THEN
  FOR i = 0 TO elementCount-1
    IF values1(i) <> values2(i) OR values1(i) <> values3(i) THEN
      PRINT "Difference at ["; i; "]: "; values1(i); " <-> "; values2(i); " <-> "; values3(i)
    END IF
  NEXT i
END IF
DO
  PRINT "Show arrays (yes/no)?"; : INPUT show
LOOP UNTIL show = "yes" OR show = "no"
IF show = "yes" THEN
  FOR i = 0 TO elementCount - 1
    PRINT "["; i; "]:\t"; values1(i); "\t"; values2(i); "\t"; values3(i)
  NEXT i
END IF
END
REM  
REM Implements the well-known BubbleSort algorithm. 
REM Compares neigbouring elements and swaps them in case of an inversion. 
REM Repeats this while inversions have been found. After every 
REM loop passage at least one element (the largest one out of the 
REM processed subrange) finds its final place at the end of the 
REM subrange. 
REM TODO: Check (and specify if needed) the argument and result types! 
SUB bubbleSort(values)
  REM TODO: declare your variables here: 
    REM DIM temp AS <type> 
    REM DIM posSwapped AS <type> 
    REM DIM i AS <type> 
    REM DIM ende AS <type> 
  REM  
  ende = length(values) - 2
  DO
    REM The index of the most recent swapping (-1 means no swapping done). 
    posSwapped = -1
    FOR i = 0 TO ende
      IF values(i) > values(i+1) THEN
        temp = values(i)
        values(i) = values(i+1)
        values(i+1) = temp
        posSwapped = i
      END IF
    NEXT i
    ende = posSwapped - 1
  LOOP UNTIL posSwapped < 0
END SUB
REM  
REM Given a max-heap 'heap´ with element at index 'i´ possibly 
REM violating the heap property wrt. its subtree upto and including 
REM index range-1, restores heap property in the subtree at index i 
REM again. 
REM TODO: Check (and specify if needed) the argument and result types! 
SUB maxHeapify(heap, i, range)
  REM TODO: declare your variables here: 
    REM DIM temp AS <type> 
    REM DIM right AS <type> 
    REM DIM max AS <type> 
    REM DIM left AS <type> 
  REM  
  REM Indices of left and right child of node i 
  right = (i+1) * 2
  left = right - 1
  REM Index of the (local) maximum 
  max = i
  IF left < range AND heap(left) > heap(i) THEN
    max = left
  END IF
  IF right < range AND heap(right) > heap(max) THEN
    max = right
  END IF
  IF max <> i THEN
    temp = heap(i)
    heap(i) = heap(max)
    heap(max) = temp
    CALL maxHeapify(heap, max, range)
  END IF
END SUB
REM  
REM Partitions array values between indices start und stop-1 with 
REM respect to the pivot element initially at index p into smaller 
REM and greater elements. 
REM Returns the new (and final) index of the pivot element (which 
REM separates the sequence of smaller from the sequence of greater 
REM elements). 
REM This is not the most efficient algorithm (about half the swapping 
REM might still be avoided) but it is pretty clear. 
REM TODO: Check (and specify if needed) the argument and result types! 
FUNCTION partition(values, start, stop, p) AS Integer
  REM TODO: declare your variables here: 
    REM DIM seen AS <type> 
    REM DIM pivot AS <type> 
  REM  
  pivot = values(p)
  REM Tausche das Pivot-Element an den start 
  values(p) = values(start)
  values(start) = pivot
  p = start
  REM Beginning and end of the remaining unknown range 
  start = start + 1
  stop = stop - 1
  REM Still unseen elements? 
  DO WHILE stop >= start
    seen = values(start)
    IF values(start) <= pivot THEN
      REM Swap pivot element with start element 
      values(p) = seen
      values(start) = pivot
      p = p + 1
      start = start + 1
    ELSE
      REM Put the found element to the end of the unknown area 
      values(start) = values(stop)
      values(stop) = seen
      stop = stop - 1
    END IF
  LOOP
  return p
END FUNCTION
REM  
REM Checks whether or not the passed-in array is (ascendingly) sorted. 
REM TODO: Check (and specify if needed) the argument and result types! 
FUNCTION testSorted(numbers) AS bool
  REM TODO: declare your variables here: 
    REM DIM isSorted AS <type> 
    REM DIM i AS <type> 
  REM  
  isSorted = true
  i = 0
  REM As we compare with the following element, we must stop at the penultimate index 
  DO WHILE isSorted AND (i <= length(numbers)-2)
    REM Is there an inversion? 
    IF numbers(i) > numbers(i+1) THEN
      isSorted = false
    ELSE
      i = i + 1
    END IF
  LOOP
  return isSorted
END FUNCTION
REM  
REM Runs through the array heap and converts it to a max-heap 
REM in a bottom-up manner, i.e. starts above the "leaf" level 
REM (index >= length(heap) div 2) and goes then up towards 
REM the root. 
REM TODO: Check (and specify if needed) the argument and result types! 
FUNCTION buildMaxHeap(heap)
  REM TODO: declare your variables here: 
    REM DIM lgth AS <type> 
    REM DIM k AS <type> 
  REM  
  lgth = length(heap)
  FOR k = lgth / 2 - 1 TO 0 STEP -1
    CALL maxHeapify(heap, k, lgth)
  NEXT k
  RETURN 0
END FUNCTION
REM  
REM Recursively sorts a subrange of the given array 'values´.  
REM start is the first index of the subsequence to be sorted, 
REM stop is the index BEHIND the subsequence to be sorted. 
REM TODO: Check (and specify if needed) the argument and result types! 
FUNCTION quickSort(values, start, stop)
  REM TODO: declare your variables here: 
    REM DIM p AS <type> 
  REM  
  REM At least 2 elements? (Less don't make sense.) 
  IF stop >= start + 2 THEN
    REM Select a pivot element, be p its index. 
    REM (here: randomly chosen element out of start ... stop-1) 
    p = random(stop-start) + start
    REM Partition the array into smaller and greater elements 
    REM Get the resulting (and final) position of the pivot element 
    CALL p = partition(values, start, stop, p)
    REM Sort subsequances separately and independently ... 

    REM ========================================================== 
    REM ================= START PARALLEL SECTION ================= 
    REM ========================================================== 
    REM TODO: add the necessary code to run the threads concurrently 

      REM ----------------- START THREAD 0 ----------------- 
        REM Sort left (lower) array part 
        CALL quickSort(values, start, p)
      REM ------------------ END THREAD 0 ------------------ 


      REM ----------------- START THREAD 1 ----------------- 
        REM Sort right (higher) array part 
        CALL quickSort(values, p+1, stop)
      REM ------------------ END THREAD 1 ------------------ 

    REM ========================================================== 
    REM ================== END PARALLEL SECTION ================== 
    REM ========================================================== 

  END IF
  RETURN 0
END FUNCTION
REM  
REM Sorts the array 'values´ of numbers according to he heap sort 
REM algorithm 
REM TODO: Check (and specify if needed) the argument and result types! 
FUNCTION heapSort(values)
  REM TODO: declare your variables here: 
    REM DIM maximum AS <type> 
    REM DIM k AS <type> 
    REM DIM heapRange AS <type> 
  REM  
  CALL buildMaxHeap(values)
  heapRange = length(values)
  FOR k = heapRange - 1 TO 1 STEP -1
    heapRange = heapRange - 1
    REM Swap the maximum value (root of the heap) to the heap end 
    maximum = values(0)
    values(0) = values(heapRange)
    values(heapRange) = maximum
    CALL maxHeapify(values, 0, heapRange)
  NEXT k
  RETURN 0
END FUNCTION
